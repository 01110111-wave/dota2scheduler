package callapi

import (
	"dotascheduler/util"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"sync"
	"time"
)

var wg sync.WaitGroup

func GetAllLeagueSchedule(league_ids []int) []util.League {

	url := "https://www.dota2.com/webapi/IDOTA2League/GetLeaguesData/v001?league_ids="
	for i, league_id := range league_ids {
		if i >= 1 {
			url = url + ","
		}
		url = url + strconv.Itoa(league_id)
	}
	//response, err := http.Get("https://www.dota2.com/webapi/IDOTA2League/GetLeaguesData/v001?league_ids=14892,14893")
	response, err := http.Get(url)
	if err != nil {
		fmt.Println("error getting http response", err)
	}
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		fmt.Println("error reading body", err)
	}
	var schecule util.AutoGenerated
	err = json.Unmarshal(body, &schecule)
	if err != nil {
		fmt.Println("Error unmarshaling JSON:", err)
	}

	ans := []util.League{}
	ansC := make(chan util.League)

	for _, league := range schecule.Leagues {
		league := league
		wg.Add(1)
		go func() {
			idtoteam := map[int]util.Team{}
			matchs := []util.Match{}
			all_team := league.NodeGroups[0].TeamStandings
			for _, team := range all_team {
				idtoteam[team.TeamID] = util.Team{Name: team.TeamName, Tag: team.TeamTag}
			}
			all_match := league.SeriesInfos
			for _, match := range all_match {
				startime := time.Unix(int64(match.StartTime), 0).Truncate(5 * time.Minute)
				bo := match.SeriesType*2 + 1
				matchs = append(matchs, util.Match{Team1: idtoteam[match.TeamID1], Team2: idtoteam[match.TeamID2], StartTime: startime, UnixStartTime: match.StartTime, BO: bo})
			}

			ansC <- util.League{Name: league.Info.Name, Region: util.RegionIntToRegionString(league.Info.Region), Matchs: matchs}
			wg.Done()
		}()
	}

	for range league_ids {
		ans = append(ans, <-ansC)
	}

	wg.Wait()
	return ans
}
